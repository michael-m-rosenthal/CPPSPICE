Today I am going to study the style guide used by NAIF for SPICE 2.

I am not able to access the link to the atom snippets [SPICE-2.0/src/prototypes/wiki/atom/snippets.cson]( https://github.jpl.nasa.gov/NAIF/SPICE-2.0/raw/master/src/prototypes/wiki/atom/snippets.cson ).

Can I automate the file version and date string?

```
// SPICE2 Version 1.0.0, 01-JAN-2017 (XXX)
```

The following script may be used to automatically replace the old version string with a new one.

```
#!/bin/bash


#old_tag="// SPICE2 Version 1.0.0, 01-JAN-2017 (XXX)"
# pass in the old version string as an argument
old_tag=$1
initials="MMR"
version="0.0.0"
today=`date -u +%d-%b-%Y`
new_tag="// SPICE2 Version $version, $today ($initials)"

echo $old_tag
echo $new_tag
# Recursively find and replace in files
find . -name "*.hpp" -exec sed -i'' -e "s:$old_tag:$new_tag:g" {} +

```

CamelCase class
camelCase instance
m_camelCase member variable
camelCase methods
I already do macros, enumerator values and constants LIKE_THIS
use namespaces all lowercase


I do not use using namespace because I've been burned with simple math functions like `abs` not working correctly because of it.

Do not modify the precision of std::cout


This one I actually need to look at.

```
Use correct resource handling
Resource Acquisition is Initialization (RAII) idiom

Smart pointers

DO: std::unique_ptr< SpiceClass > ptr( new SpiceClass ); DON'T: SpiceClass* ptr( new SPICEClass );
```

[from here](https://en.cppreference.com/w/cpp/memory/unique_ptr)

```
std::unique_ptr is a smart pointer that owns and manages another object through a pointer and disposes of that object when the unique_ptr goes out of scope.
```

So the way I would have handled it in the past would be check that pointer is not null, if so delete it and the pointer to zero.

```
The object is disposed of, using the associated deleter when either of the following happens:

the managing unique_ptr object is destroyed
the managing unique_ptr object is assigned another pointer via operator= or reset().
```

Is the deleter the same thing as the desconstructor? yes


```
As unique_ptr<> is not copyable, only movable. Hence we can not create copy of a unique_ptr object either through copy constructor or assignment operator.
```

How do you pass in a unique_ptr if it is not copyable?


```
We cannot copy a unique_ptr object, but we can move them. It means a unique_ptr object can transfer the owner ship of associated raw pointer to another unique_ptr object. Letâ€™s understand by an example,
// Create a unique_ptr object through raw pointer
std::unique_ptr<Task> taskPtr2(new Task(55));
std::unique_ptr<Task> taskPtr4 = std::move(taskPtr2);
```

Look like you need to use `std::move()` to transfer the unique ptr

[how do I use smart pointers?](https://www.geeksforgeeks.org/smart-pointers-cpp/)

Usually I just use vectors because it automatically calls the destructor, and if I want to pass in a single value, I just pass it in as a reference.
I am going to proceed with that convention with this coding project until I learn otherwise.


```
Do not write custom destructors. They are not guaranteed to execute in C++11 when an object goes out of scope.
```

Okay. That is the first time I have heard about that. I suppose it would eventually execute before the program ends.

okay Try/Catch Blocks. I actually like assertion statements like the following.

```
assert(false && "some description of what went wrong");
```

I feel they are more compact.

`Don't use C-style casting`


```
#include <iosfwd> in a header file (not #include <iostream>) if you use only a reference or a pointer to any of the standard input/output library types
```

I am not sure about this one.

```
Use header file protectors
```

I already do that, check.

```
Don't rely on a second order includes and provide #include directive for each necessary header file to be included. For example, if "class1.hpp" includes "class2.hpp", and the code requires definition of both classes at compile time, then include both header files into the compilation module:

// // DO: // #include "class1.hpp" #include "class2.hpp"

// // DO NOT even though it is sufficient for the time being: // #include "class1.hpp"
```

okay

```
Explicitly delete unneeded class methods that are implicitly generated by the compiler otherwise
```

I do not know about this one either.


```
Declare variables as locally as possible
Never declare a variable before you can initialize it sensibly
Always initialize variables
```

okay, the only one I do not already do is the third one. noted.


```
Overload operators only for good reason
Preserve natural semantics
When defining binary arithmetic operators, provide their assignment versions as well: if you a+b, also a+=b (operator+ is implemented in terms of operator+=)
```

okay

```
Prefer std:: algorithms to handwritten loops
```

sure


so the things I need to ask for clarity on:


Explicitly delete unneeded class methods that are implicitly generated by the compiler otherwise
Do not write custom destructors. They are not guaranteed to execute in C++11 when an object goes out of scope.

I think in the future that when I pass in an pointer that does not change, I can use a unique_ptr.
In the past I have used CONST pointers, mainly to make it difficult for someone to do something stupid like reassign the pointer while I am computing something with it.


## loading data

I looked at the generic kerels found [here](https://naif.jpl.nasa.gov/naif/data_generic.html).
I am going to need an SPK for the planets.
I found the following description.

```
For those whose need of a planet ephemeris can be satisfied by the DE430 time span, and for
those in need of the most accurate JPL-produced lunar ephemeris, DE430 is now considered
the official export ephemeris.

  de430.bsp
  Approximate file size:   120 Mbytes
  Approximate time span:   1550 Jan 01 to 2650 Jan 22
```  

So I think that `de430.bsp` will suffice for this application

what else do I need to load?

So in the `gfoclt_c` example, they use the following kernels

```
furnsh_c( "naif0008.tls"  );
furnsh_c( "de421.bsp"     );
furnsh_c( "pck00008.tpc"  );
```


In think `de430.bsp` is a more recent version than `de421.bsp`, and I will use the newer ephemeris data.
There is a technical write-up I want read too [right here](https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/de430_moon_coord.pdf).

I think I will need some information about the shape of the moon and earth and sun.
So will need to load a planetary constant kernel PCK.
I probably do not need the larget earth and moon binaries for this application.
